# -*- coding: utf-8 -*-
"""итоговый

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eS1uPbYlYSs3NHcpuvS-bFyGFotdqayi
"""

# -*- coding: utf-8 -*-
"""
Скрипт для автоматической обработки PDF-документов о штрафах,
включающий загрузку, распознавание текста и номеров автомобилей,
формирование таблиц и отправку уведомлений.

Использует OpenAI Drive API, PyMuPDF, EasyOCR, Tesseract, pandas и yagmail.
"""

# --- 1. Установка и импорт библиотек ---
!pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib
!pip install pymupdf
!pip install Pillow
!pip install easyocr
!pip install pandas
!pip install opencv-python
!pip install pdf2image
!apt-get install -y poppler-utils
!apt-get remove tesseract-ocr
!apt-get install tesseract-ocr
!apt-get install -y libleptonica-dev
!apt-get install -y tesseract-ocr-rus
!pip install pytesseract
!pip install pdfplumber
!pip install openpyxl yagmail

from google.colab import auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload
from datetime import datetime, date
import os
import io
import re
import pandas as pd
import fitz  # PyMuPDF
from PIL import Image
import easyocr
import cv2
from pdf2image import convert_from_path
from google.colab.patches import cv2_imshow
import pytesseract
from PIL import Image, ImageEnhance
import logging
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import yagmail

# --- 2. Работа с OpenAI Drive API ---
# Авторизация
auth.authenticate_user()
print("Authentication successful!")

# Создание сервиса Google Drive API
drive_service = build('drive', 'v3')

# Функция для поиска папки на Google Drive
def find_folder(service, folder_name):
    results = service.files().list(
        q=f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder'",
        spaces='drive',
        fields='files(id, name)'
    ).execute()
    folders = results.get('files', [])
    return folders[0] if folders else None

# Функция для поиска папок, созданных сегодня
def find_folders_created_today(service, parent_folder_id):
    today = datetime.utcnow().date().isoformat()
    query = (
        f"'{parent_folder_id}' in parents and "
        "mimeType='application/vnd.google-apps.folder' and "
        f"createdTime >= '{today}T00:00:00' and "
        f"createdTime <= '{today}T23:59:59'"
    )
    results = service.files().list(
        q=query, spaces='drive', fields='files(id, name, createdTime)'
    ).execute()
    return results.get('files', [])

# Функция для скачивания PDF-файлов
def download_pdfs(service, folder_id, download_path):
    os.makedirs(download_path, exist_ok=True)
    query = f"'{folder_id}' in parents and mimeType='application/pdf'"
    results = service.files().list(q=query, spaces='drive', fields='files(id, name)').execute()
    files = results.get('files', [])

    for file in files:
        file_id = file['id']
        file_name = file['name']
        request = service.files().get_media(fileId=file_id)
        file_path = os.path.join(download_path, file_name)
        with open(file_path, 'wb') as f:
            downloader = MediaIoBaseDownload(f, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
            print(f"Downloaded: {file_name}")

# --- 3. Работа с PDF файлами ---

# Функция для извлечения данных из PDF
def extract_pdf_data(pdf_path):
    try:
        doc = fitz.open(pdf_path)
        text = ""

        # Извлекаем текст с каждой страницы
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            text += page.get_text("text")

        # Извлекаем изображения
        images = []
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            image_list = page.get_images(full=True)
            for img_index, image in enumerate(image_list):
                xref = image[0]
                base_image = doc.extract_image(xref)
                image_bytes = base_image["image"]
                images.append((image_bytes,f"{pdf_path.split('/')[-1]}_page_{page_num}_img_{img_index}.jpeg"))


        return text, images
    except Exception as e:
        print(f"Error extracting data from {pdf_path}: {e}")
        return "", []


# Функция для извлечения данных о нарушении
def extract_violation_data(text, pdf_file):
    # Приведение текста к верхнему регистру для унификации
    text = text.upper()

    # Инициализация переменных
    violation_number, fine_amount = None, None
    violation_date, violation_time = None, None
    violation_address, vehicle_number, stc_number = None, None, None
    vehicle_photo, vehicle_reg_photo, vehicle_reg_number = None, None, None
    igr_number = None

     # Номер постановления
    match_number = re.search(r'ПОСТАНОВЛЕНИЕ\s+(\d+)', text)
    if match_number:
        violation_number = match_number.group(1)

    # Сумма штрафа
    fine_patterns = [
        r'НАЗНАЧИТЬ\s+.*?\s+ШТРАФА\s+В\s+РАЗМЕРЕ\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)',
        r'ШТРАФ\s+В\s+(РАЗМЕРЕ|СУММЕ)\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)',
        r'РАЗМЕР\s+ШТРАФА\s+СОСТАВЛЯЕТ\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)'
    ]
    for pattern in fine_patterns:
        match_fine = re.search(pattern, text)
        if match_fine:
            fine_amount = match_fine.group(1)
            fine_amount = fine_amount.replace(" ", "").replace(".", "").replace("\xa0", "")  # Удаление пробелов
            fine_amount = int(fine_amount)
            break
    else:
        fine_amount = 0  # Если сумма не найдена

    # Дата и время нарушения
    match_date_time = re.search(r'(\d{2}\.\d{2}\.\d{4})\s+В\s+(\d{2}:\d{2}:\d{2})', text)
    if match_date_time:
        violation_date = match_date_time.group(1)
        violation_time = match_date_time.group(2)

    # Адрес нарушения (более гибкий поиск)
    match_address = re.search(r'ПО АДРЕСУ\s+([^\n]+?)(?=\s+(?:ВОДИТЕЛЬ|ГРАЖДАНИН|\d{2}\.\d{2}\.\d{4}|\s*ПОСТАНОВЛЕНИЕ|АВТОМОБИЛЬ|ТРАНСПОРТНОЕ СРЕДСТВО|ТС,|НАПРАВЛЕНИЕ ДВИЖЕНИЯ|РБ,|ОБЛ\.|РЕСП\.))', text, re.DOTALL)
    if match_address:
        violation_address = match_address.group(1).strip()

    # Номер ТС (с учетом формата ВР618116 и Н903ОТ716)
    match_vehicle_number = re.search(r'([А-Я]{1}\d{3}[А-Я]{2}\d{2,3}|[А-Я]{2}\d{4}\d{2,3})', text)
    if match_vehicle_number:
        vehicle_number = match_vehicle_number.group(1)
        vehicle_reg_number = vehicle_number

    # Номер СТС
    match_stc_number = re.search(r'\d{10}', text)
    if match_stc_number:
        stc_number = match_stc_number.group(0)

    # Фотография ТС
    vehicle_photo_dir = '/content/images/'
    matching_images = [img for img in os.listdir(vehicle_photo_dir) if pdf_file.split('.')[0] in img]
    if matching_images:
        vehicle_photo = os.path.join(vehicle_photo_dir, matching_images[0])  # Первое совпадение

    # Фотография гос номера
    if 'ФОТО ГОС НОМЕРА ТС' in text:
        vehicle_reg_photo = "Найдена фотография гос номера"

    # ИГР знак
    match_igr = re.search(r'ИГР\s+(\d+)', text)
    if match_igr:
        igr_number = match_igr.group(1).strip()
    else:
        igr_number = "Не определено"

    return {
        'Номер постановления': violation_number or "Не найдено",
        'Сумма штрафа': fine_amount,
        'Сумма штрафа > или < 5000 (True/False)': fine_amount > 5000,
        'Дата нарушения': violation_date or "Не найдено",
        'Время нарушения': violation_time or "Не найдено",
        'Адрес нарушения': violation_address or "Не найдено",
        'Номер ТС': vehicle_number or "Не найдено",
        'Номер СТС': stc_number or "Не найдено",
        'Фотография ТС': vehicle_photo or "Не найдено",
        'Фото гос номера ТС': vehicle_reg_photo or "Не найдено",
        'Гос номер ТС': vehicle_reg_number or "Не найдено",
        'ИГР знак': igr_number
    }

# Функция для обработки всех PDF и обновления файла CSV
def process_all_pdfs(pdf_folder, csv_output):
    pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith('.pdf')]

    # Загружаем существующий файл CSV в DataFrame, если файл существует, иначе создаем новый
    if os.path.isfile(csv_output):
        df = pd.read_csv(csv_output)
    else:
        df = pd.DataFrame()

    for pdf_file in pdf_files:
        pdf_path = os.path.join(pdf_folder, pdf_file)
        text, images = extract_pdf_data(pdf_path)

        if not text:  # Skip if no data was extracted
            continue

        # Сохранение картинок на диск
        image_folder = "/content/images/"
        if not os.path.exists(image_folder):
            os.makedirs(image_folder)
        for image_bytes, img_name in images:
            with open(os.path.join(image_folder, img_name), "wb") as f:
               f.write(image_bytes)

        extracted_data = extract_violation_data(text, pdf_file)

        # Если запись найдена, обновляем её; иначе добавляем новую строку
        idx = df[df['Номер постановления'] == extracted_data['Номер постановления']].index

        # Добавляем имя файла
        extracted_data['Номер файла'] = pdf_file

        if not idx.empty:
            df.loc[idx, 'Сумма штрафа'] = extracted_data['Сумма штрафа']
            df.loc[idx, 'Сумма штрафа > или < 5000 (True/False)'] = extracted_data[
                'Сумма штрафа > или < 5000 (True/False)']
            df.loc[idx, 'Дата нарушения'] = extracted_data['Дата нарушения']
            df.loc[idx, 'Время нарушения'] = extracted_data['Время нарушения']
            df.loc[idx, 'Адрес нарушения'] = extracted_data['Адрес нарушения']
            df.loc[idx, 'Номер ТС'] = extracted_data['Номер ТС']
            df.loc[idx, 'Номер СТС'] = extracted_data['Номер СТС']
            df.loc[idx, 'Фотография ТС'] = extracted_data['Фотография ТС']
            df.loc[idx, 'Фото гос номера ТС'] = extracted_data['Фото гос номера ТС']
            df.loc[idx, 'Гос номер ТС'] = extracted_data['Гос номер ТС']
            df.loc[idx, 'ИГР знак'] = extracted_data['ИГР знак']
            df.loc[idx, 'Номер файла'] = extracted_data['Номер файла']
        else:
            new_row = {key: None for key in df.columns}  # Создаём шаблон строки
            new_row.update(extracted_data)  # Заполняем новой информацией
            df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)

        # Вывод для отладки
        print(f"Файл: {pdf_file}")
        print(f"Номер постановления: {extracted_data['Номер постановления']}")
        print(f"Сумма штрафа: {extracted_data['Сумма штрафа']}")
        print(f"Флаг: {extracted_data['Сумма штрафа > или < 5000 (True/False)']}")
        print("-" * 50)

    # Убедимся, что новый столбец вставлен между 'Сумма штрафа' и 'Номер СТС'
    cols = df.columns.tolist()
    sum_index = cols.index('Сумма штрафа')
    if 'Сумма штрафа > или < 5000 (True/False)' in cols:
        cols.remove('Сумма штрафа > или < 5000 (True/False)')
    cols.insert(sum_index + 1, 'Сумма штрафа > или < 5000 (True/False)')
    df = df[cols]

    # Запись в CSV
    df.to_csv(csv_output, index=False, encoding='utf-8-sig')
    print(f"Данные записаны в файл:\nCSV: {csv_output}")

# --- 4. Компьютерное зрение для распознавания номеров ---

# Конвертация PDF в изображение
def pdf_to_image(pdf_path, output_folder='output_images'):
    """Конвертирует PDF в изображение (первая страница)."""
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
    try:
        images = convert_from_path(pdf_path, poppler_path='/usr/bin')
        image_path = os.path.join(output_folder, "page1.jpeg")
        images[0].save(image_path, 'JPEG')
        return image_path
    except Exception as e:
        logging.error(f"Ошибка при конвертации PDF в изображение: {e}")
        return None


# Загрузка изображения и распознавание текста c Tesseract
def ocr_image_tesseract(image_path, contrast=2.0, sharpness=2.0, resize_factor=1.5):
    """Распознает текст на изображении с помощью Tesseract."""
    try:
        image = Image.open(image_path)
        if resize_factor != 1:
            new_size = (int(image.width * resize_factor), int(image.height * resize_factor))
            image = image.resize(new_size, Image.Resampling.LANCZOS)
        image = image.convert("L")
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(contrast)
        sharpener = ImageEnhance.Sharpness(image)
        image = sharpener.enhance(sharpness)
        text = pytesseract.image_to_string(image, lang='rus')
        return text
    except Exception as e:
        logging.error(f"Ошибка при распознавании текста Tesseract: {e}")
        return None


# Нахождение номера ТС в тексте
def extract_plate_from_text(text):
    """Извлекает номер ТС из текста по ключевому слову."""
    if not text:
        return None
    keyword = "государственный регистрационный знак"
    match = re.search(rf'{keyword}\s*([АВЕКМНОРСТУХABEKMHOPCTYX]\s*\d{{3}}\s*[АВЕКМНОРСТУХABEKMHOPCTYX]{{2}}\s*\d{{2,3}})', text, re.IGNORECASE)
    if match:
        return _normalize_plate(match.group(1))
    else:
        return None


# Распознавание номера ТС на фото
def ocr_plate_from_image(image_path):
    """Распознает номер ТС на изображении с помощью EasyOCR."""
    try:
        reader = easyocr.Reader(['ru'])
        image = cv2.imread(image_path)
        if image is None:
            logging.error(f"Не удалось прочитать изображение по пути: {image_path}")
            return None
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        gray = cv2.medianBlur(gray, 5)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 5)

        results = reader.readtext(thresh)
        plates = [result[1] for result in results if re.match(r'[АВЕКМНОРСТУХABEKMHOPCTYX]\d{3}[АВЕКМНОРСТУХABEKMHOPCTYX]{2}\d{2,3}', result[1])]
        if plates:
            return _normalize_plate(plates[0])
        else:
          return None
    except Exception as e:
        logging.error(f"Ошибка при распознавании номера с изображения: {e}")
        return None


# Унифицированная функция для нормализации номеров
def _normalize_plate(plate):
    """Нормализует номер ТС, удаляя пробелы, запятые, точки, двоеточия и невидимые символы."""
    if plate is None:
      return None
    if plate:
        plate = plate.upper()
        plate = re.sub(r'[\s,.;:\n\t]', '', plate)
        return plate
    return plate


def compare_plates(text_plate, image_plate):
    """Сравнивает два номера ТС."""
    if text_plate and image_plate:
      return text_plate == image_plate
    else:
      return False

# Функция для обработки одного PDF
def process_single_pdf(pdf_path):
    """Обрабатывает один PDF файл."""
    logging.info(f"Обработка PDF: {pdf_path}")
    image_path = pdf_to_image(pdf_path)
    if not image_path:
      logging.error(f"Не удалось получить изображение из {pdf_path}")
      return None, None, False
    text = ocr_image_tesseract(image_path)
    text_plate = extract_plate_from_text(text)
    image_plate = ocr_plate_from_image(image_path)
    result = compare_plates(text_plate, image_plate)
    logging.info(f"Результаты: Text Plate={text_plate}, Image Plate={image_plate}, Match={result}")
    return text_plate, image_plate, result

# Функция для обработки всех PDF в папке
def process_pdf_folder(folder_path, output_csv="/content/output/violations_data.csv"):
    """Обрабатывает все PDF файлы в указанной папке и записывает результаты в CSV."""
    if not os.path.exists(folder_path):
        logging.error(f"Папка не найдена: {folder_path}")
        return

    # Читаем существующий CSV файл
    try:
      df = pd.read_csv(output_csv)
    except FileNotFoundError:
        logging.error(f"Файл CSV не найден: {output_csv}")
        return

    new_column_data = []
    for filename in os.listdir(folder_path):
        if filename.lower().endswith(".pdf"):
            pdf_path = os.path.join(folder_path, filename)
            try:
              text_plate, image_plate, result = process_single_pdf(pdf_path)
              new_column_data.append(result)
            except Exception as e:
                logging.error(f"Ошибка при обработке PDF {pdf_path}: {e}")
                new_column_data.append(False) # Если ошибка, то ставим False

    # Вставляем новый столбец после столбца "Фото гос номера ТС"
    try:
      insert_loc = df.columns.get_loc("Фото гос номера ТС") + 1
      df.insert(insert_loc, "Фото гос номера соответствуют (True/False)", new_column_data)
    except KeyError:
      logging.error(f"Столбец 'Фото гос номера ТС' не найден в CSV.")
      return


    # Сохраняем обновленный DataFrame обратно в CSV
    df.to_csv(output_csv, index=False, encoding='utf-8')
    return

# --- 5. Создание сводной таблицы и отправка email ---
def create_summary_table(csv_path):
    """
    Создает итоговую таблицу с подсчетом нарушений по адресам.

    Args:
      csv_path: Путь к CSV-файлу с данными о нарушениях.

    Returns:
      pandas.DataFrame: Итоговая таблица.  Возвращает None при ошибках.
    """
    try:
        # Загрузка данных из CSV
        df_csv = pd.read_csv(csv_path)
    except FileNotFoundError as e:
        print(f"Ошибка при чтении CSV: {e}")
        return None
    except pd.errors.EmptyDataError:
        print("CSV файл пуст")
        return None
    except Exception as e:
        print(f"Ошибка при чтении CSV: {e}")
        return None

    # Обработка пустых значений в столбце 'Адрес нарушения'
    df_csv = df_csv.dropna(subset=['Адрес нарушения'])

    # Подсчет количества нарушений по адресам
    summary_df = df_csv['Адрес нарушения'].value_counts().reset_index()
    summary_df.columns = ['Адрес местоположения', 'Количество']
    summary_df.sort_values('Количество', ascending=False, inplace=True) # Сортировка

    # Добавляем нумерацию
    summary_df.insert(0, '№', range(1, len(summary_df) + 1))
    return summary_df

def send_email(summary_table, recipient_email, sender_email, sender_password):
    """
    Отправляет итоговую таблицу на почту в формате Excel.

    Args:
        summary_table (pandas.DataFrame): Итоговая таблица.
        recipient_email (str): Адрес электронной почты получателя.
        sender_email (str): Адрес электронной почты отправителя (Gmail).
        sender_password (str): Пароль электронной почты отправителя (Gmail).
    """

    # Создание временного файла для таблицы
    temp_file = "summary_table.xlsx"
    summary_table.to_excel(temp_file, index=False)

    # Формирование письма
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email
    message['Subject'] = "Итоговая таблица нарушений"

    # Текст письма
    body = "Прилагается итоговая таблица с количеством нарушений по адресам."
    message.attach(MIMEText(body, 'plain'))

    # Добавление файла с таблицей в качестве вложения
    with open(temp_file, "rb") as attachment:
        part = MIMEApplication(attachment.read(), Name=os.path.basename(temp_file))
    part['Content-Disposition'] = f'attachment; filename="{os.path.basename(temp_file)}"'
    message.attach(part)

    try:
       # Подключение к SMTP-серверу и отправка
       server = smtplib.SMTP("smtp.gmail.com", 587)
       server.starttls()
       server.login(sender_email, sender_password)
       server.sendmail(sender_email, recipient_email, message.as_string())
       server.quit()
       print("Письмо с таблицей успешно отправлено.")
    except Exception as e:
       print(f"Ошибка при отправке письма: {e}")
    finally:
        # Удаление временного файла
       os.remove(temp_file)

# --- 6. Основная логика ---
if __name__ == "__main__":
    # --- 6.1 Настройка папок и путей ---
    today = date.today()
    pdf_folder_name = today.strftime("%d.%m.%Y")
    pdf_folder = os.path.join("/content", f"{pdf_folder_name}_downloads")
    csv_output = '/content/output/violations_data.csv'  # Путь для сохранения CSV
    output_csv = "/content/output/violations_data.csv"  # Полный путь

    # Проверяем, существует ли директория для сохранения CSV файла, если нет, создаем ее
    if not os.path.exists(os.path.dirname(output_csv)):
      os.makedirs(os.path.dirname(output_csv)) # Создаем директорию output если ее нет


    # --- 6.2 Скачивание PDF с OpenAI Drive ---
    try:
        fines_folder = find_folder(drive_service, "Штрафы")
        if not fines_folder:
            print("Папка 'Штрафы' не найдена.")
        else:
            print(f"Папка 'Штрафы' найдена: {fines_folder['name']} ({fines_folder['id']})")
            today_folders = find_folders_created_today(drive_service, fines_folder['id'])

            if not today_folders:
                print("Сегодня не было создано папок в 'Штрафы'.")
            else:
                for folder in today_folders:
                    print(f"Папка: {folder['name']} (ID: {folder['id']})")
                    download_path = f"/content/{folder['name']}_downloads"
                    download_pdfs(drive_service, folder['id'], download_path)

    except HttpError as error:
        print(f"Произошла ошибка API: {error}")


    # --- 6.3 Обработка PDF файлов и сохранение данных ---
    if not os.path.exists(pdf_folder):
      print(f"Папка с PDF файлами не найдена: {pdf_folder}. Пожалуйста убедитесь, что она создана.")
    else:
       process_all_pdfs(pdf_folder, csv_output)
       process_pdf_folder(pdf_folder, output_csv=output_csv)


    # --- 6.4 Создание итоговой таблицы и отправка email ---
    summary_table = create_summary_table(csv_output)
    if summary_table is not None:
        print("Итоговая таблица:")
        print(summary_table)
        recipient = "ipfarm@mail.ru"
        sender = "nikita5867@gmail.com"  # Ваш адрес Gmail
        password = "hnnt eoua jifr ktnv"  # Ваш пароль от Gmail  (Свой пароль удалить)
        send_email(summary_table, recipient, sender, password)

# Проверка загруженных файлов
print("Содержимое директории загрузки:")
!ls /content/*_downloads

"""
Скрипт для автоматической обработки PDF-документов о штрафах,
включающий загрузку, распознавание текста и номеров автомобилей,
формирование таблиц и отправку уведомлений.

Использует OpenAI Drive API, PyMuPDF, EasyOCR, Tesseract, pandas и yagmail.
"""

# --- 1. Установка и импорт библиотек ---
!pip install google-api-python-client google-auth-httplib2 google-auth-oauthlib
!pip install pymupdf
!pip install Pillow
!pip install easyocr
!pip install pandas
!pip install opencv-python
!pip install pdf2image
!apt-get install -y poppler-utils
!apt-get remove tesseract-ocr
!apt-get install tesseract-ocr
!apt-get install -y libleptonica-dev
!apt-get install -y tesseract-ocr-rus
!pip install pytesseract
!pip install pdfplumber
!pip install openpyxl yagmail

from google.colab import auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaIoBaseDownload
from datetime import datetime, date
import os
import io
import re
import pandas as pd
import fitz  # PyMuPDF
from PIL import Image
import easyocr
from datetime import date
import cv2
import numpy as np
from pdf2image import convert_from_path
from google.colab.patches import cv2_imshow
import pytesseract
from PIL import Image, ImageEnhance
import logging
import smtplib
import glob
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication
import yagmail
from google.colab import files

# --- 2. Работа с OpenAI Drive API ---

# Авторизация
auth.authenticate_user()
print("Authentication successful!")

# Создание сервиса Google Drive API
drive_service = build('drive', 'v3')

# Функция для поиска папки на Google Drive
def find_folder(service, folder_name):
    results = service.files().list(
        q=f"name='{folder_name}' and mimeType='application/vnd.google-apps.folder'",
        spaces='drive',
        fields='files(id, name)'
    ).execute()
    folders = results.get('files', [])
    return folders[0] if folders else None

# Функция для поиска папок, созданных сегодня
def find_folders_created_today(service, parent_folder_id):
    today = datetime.utcnow().date().isoformat()
    query = (
        f"'{parent_folder_id}' in parents and "
        "mimeType='application/vnd.google-apps.folder' and "
        f"createdTime >= '{today}T00:00:00' and "
        f"createdTime <= '{today}T23:59:59'"
    )
    results = service.files().list(
        q=query, spaces='drive', fields='files(id, name, createdTime)'
    ).execute()
    return results.get('files', [])

# Функция для скачивания PDF-файлов
def download_pdfs(service, folder_id, download_path):
    os.makedirs(download_path, exist_ok=True)
    query = f"'{folder_id}' in parents and mimeType='application/pdf'"
    results = service.files().list(q=query, spaces='drive', fields='files(id, name)').execute()
    files = results.get('files', [])

    for file in files:
        file_id = file['id']
        file_name = file['name']
        request = service.files().get_media(fileId=file_id)
        file_path = os.path.join(download_path, file_name)
        with open(file_path, 'wb') as f:
            downloader = MediaIoBaseDownload(f, request)
            done = False
            while not done:
                status, done = downloader.next_chunk()
            print(f"Downloaded: {file_name}")

# Основная логика
try:
    fines_folder = find_folder(drive_service, "Штрафы")
    if not fines_folder:
        print("Папка 'Штрафы' не найдена.")
    else:
        print(f"Папка 'Штрафы' найдена: {fines_folder['name']} ({fines_folder['id']})")
        today_folders = find_folders_created_today(drive_service, fines_folder['id'])

        if not today_folders:
            print("Сегодня не было создано папок в 'Штрафы'.")
        else:
            for folder in today_folders:
                print(f"Папка: {folder['name']} (ID: {folder['id']})")
                download_path = f"/content/{folder['name']}_downloads"
                download_pdfs(drive_service, folder['id'], download_path)

except HttpError as error:
    print(f"Произошла ошибка API: {error}")

# Проверка загруженных файлов
print("Содержимое директории загрузки:")
!ls /content/*_downloads

# --- 3. Автоматическое извлечение самого большого изображения со второй страницы каждого PDF-файла ---

def find_largest_image_on_page(pdf_path, page_number=0, output_folder="images"):
    """
    Находит самое большое изображение на заданной странице PDF и сохраняет его.

    Args:
        pdf_path: Путь к PDF файлу.
        page_number: Номер страницы (начиная с 0).
        output_folder: Папка для сохранения изображений.

    Returns:
        Путь к сохраненному самому большому изображению, или None, если изображений не найдено.
    """
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)

    doc = fitz.open(pdf_path)
    page = doc[page_number]
    image_list = page.get_images(full=True)

    if not image_list:
        print(f"Изображений на странице не найдено в файле {pdf_path}.")
        return None

    largest_image = None
    largest_area = 0
    largest_image_name = None

    for img_index, img in enumerate(image_list):
        base_image = doc.extract_image(img[0])
        image_bytes = base_image["image"]
        image = Image.open(io.BytesIO(image_bytes))
        width, height = image.size
        area = width * height

        if area > largest_area:
            largest_area = area
            largest_image = image
            largest_image_ext = base_image['ext']
            largest_image_name =  f"image_{os.path.basename(pdf_path)}_page_{page_number + 1}_img_{img_index}.{largest_image_ext}"

    if largest_image:
         largest_image_path = os.path.join(output_folder, largest_image_name)
         largest_image.save(largest_image_path)
         print(f"Самое большое изображение из файла {pdf_path} сохранено в {largest_image_path}")
         return largest_image_path
    else:
         return None

# Получаем текущую дату
today = date.today()
# Формируем имя папки на основе текущей даты (формат ДД.ММ.ГГГГ)
pdf_folder_name = today.strftime("%d.%m.%Y")
pdf_folder = os.path.join("/content", f"{pdf_folder_name}_downloads")
output_folder = "images"  # Папка для сохранения изображений

# Проверяем существует ли папка
if not os.path.exists(pdf_folder):
    print(f"Папка с PDF файлами не найдена: {pdf_folder}. Пожалуйста убедитесь, что она создана.")
else:
    # Получаем список всех PDF файлов в папке
    pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith('.pdf')]

    # Обрабатываем каждый PDF файл
    for pdf_file in pdf_files:
        pdf_path = os.path.join(pdf_folder, pdf_file)
        image_path = find_largest_image_on_page(pdf_path, page_number=1, output_folder=output_folder)  # 1 для второй страницы

        if image_path:
            print(f"Самое большое изображение из файла {pdf_file} сохранено: {image_path}")
        else:
            print(f"Не удалось найти и сохранить самое большое изображение в файле {pdf_file}.")

# --- 4. Работа с PDF файлами ---

# Функция для извлечения данных из PDF
def extract_pdf_data(pdf_path):
    doc = fitz.open(pdf_path)

    # Извлекаем текст с каждой страницы
    text = ""
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        text += page.get_text("text")

    # Извлекаем изображения
    images = []
    for page_num in range(len(doc)):
        page = doc.load_page(page_num)
        image_list = page.get_images(full=True)
        for img_index, image in enumerate(image_list):
            xref = image[0]
            base_image = doc.extract_image(xref)
            image_bytes = base_image["image"]
            images.append((image_bytes,f"{pdf_path.split('/')[-1]}_page_{page_num}_img_{img_index}.jpeg"))

    return text, images

def extract_violation_data(text, pdf_file):
    # Приведение текста к верхнему регистру для унифицированной обработки
    text = text.upper()

    # Инициализация переменных
    violation_number, fine_amount, violation_date = None, None, None
    violation_time, violation_address, vehicle_number = None, None, None
    stc_number, vehicle_photo, vehicle_reg_photo, vehicle_reg_number, igr_number = None, None, None, None, None

     # Номер постановления
    match_number = re.search(r'ПОСТАНОВЛЕНИЕ\s+(\d+)', text)
    if match_number:
        violation_number = match_number.group(1)

    # Сумма штрафа
    fine_patterns = [
        r'НАЗНАЧИТЬ\s+ЕМУ\s+АДМИНИСТРАТИВНОЕ\s+НАКАЗАНИЕ\s+В\s+ВИДЕ\s+АДМИНИСТРАТИВНОГО\s+ШТРАФА\s+В\s+РАЗМЕРЕ\s+([\d\s]+)\s*(РУБ|РУБЛЕЙ)',
        r'ШТРАФ\s+В\s+РАЗМЕРЕ\s+([\d\s]+)\s*(РУБ|РУБЛЕЙ)',
        r'ШТРАФ\s+В\s+СУММЕ\s+([\d\s]+)\s*(РУБ|РУБЛЕЙ)',
        r'РАЗМЕР\s+ШТРАФА\s+СОСТАВЛЯЕТ\s+([\d\s]+)\s*(РУБ|РУБЛЕЙ)',
        r'ШТРАФ\s+В\s+РАЗМЕРЕ\s+([\d\s]+)\s*РУБ'
    ]
    for pattern in fine_patterns:
        match_fine = re.search(pattern, text)
        if match_fine:
            fine_amount = match_fine.group(1).strip()  # Удаление пробелов
            break

    # Дата и время нарушения
    match_date_time = re.search(r'(\d{2}\.\d{2}\.\d{4})\s+В\s+(\d{2}:\d{2}:\d{2})', text)
    if match_date_time:
        violation_date = match_date_time.group(1)
        violation_time = match_date_time.group(2)

    # Адрес нарушения (более гибкий поиск)
    match_address = re.search(r'ПО АДРЕСУ\s+([^\n]+?)(?=\s+(?:ВОДИТЕЛЬ|ГРАЖДАНИН|\d{2}\.\d{2}\.\d{4}|\s*ПОСТАНОВЛЕНИЕ|АВТОМОБИЛЬ|ТРАНСПОРТНОЕ СРЕДСТВО|ТС,|НАПРАВЛЕНИЕ ДВИЖЕНИЯ|РБ,|ОБЛ\.|РЕСП\.))', text, re.DOTALL)
    if match_address:
        violation_address = match_address.group(1).strip()

    # Номер ТС (с учетом формата ВР618116 и Н903ОТ716)
    match_vehicle_number = re.search(r'([А-Я]{1}\d{3}[А-Я]{2}\d{2,3}|[А-Я]{2}\d{4}\d{2,3})', text)
    if match_vehicle_number:
        vehicle_number = match_vehicle_number.group(1)
        vehicle_reg_number = vehicle_number

    # Номер СТС
    match_stc_number = re.search(r'\d{10}', text)
    if match_stc_number:
        stc_number = match_stc_number.group(0)

    # Фотография ТС
    vehicle_photo_dir = '/content/images/'
    matching_images = [img for img in os.listdir(vehicle_photo_dir) if pdf_file.split('.')[0] in img]
    if matching_images:
        vehicle_photo = os.path.join(vehicle_photo_dir, matching_images[0])  # Первое совпадение

    # Фотография гос номера
    if 'ФОТО ГОС НОМЕРА ТС' in text:
        vehicle_reg_photo = "Найдена фотография гос номера"

    # ИГР знак
    match_igr = re.search(r'ИГР\s+(\d+)', text)
    if match_igr:
        igr_number = match_igr.group(1).strip()
    else:
        igr_number = "Не определено"

    return {
        'Номер постановления': violation_number or "Не найдено",
        'Сумма штрафа': fine_amount or "Не найдено",
        'Дата нарушения': violation_date or "Не найдено",
        'Время нарушения': violation_time or "Не найдено",
        'Адрес нарушения': violation_address or "Не найдено",
        'Номер ТС': vehicle_number or "Не найдено",
        'Номер СТС': stc_number or "Не найдено",
        'Фотография ТС': vehicle_photo or "Не найдено",
        'Фото гос номера ТС': vehicle_reg_photo or "Не найдено",
        'Гос номер ТС': vehicle_reg_number or "Не найдено",
        'ИГР знак': igr_number
    }

def process_pdf_files(pdf_folder):
    all_data = []
    for pdf_file in os.listdir(pdf_folder):
        pdf_path = os.path.join(pdf_folder, pdf_file)

        # Предполагается наличие функции extract_pdf_data для извлечения текста
        text, images = extract_pdf_data(pdf_path)

        print(f"Текст из {pdf_file}:\n{text}")  # Вывод текста для отладки

        # Сохранение картинок на диск
        image_folder = "/content/images/"
        if not os.path.exists(image_folder):
            os.makedirs(image_folder)
        for image_bytes, img_name in images:
            with open(os.path.join(image_folder, img_name), "wb") as f:
               f.write(image_bytes)

        # Извлечение данных
        extracted_data = extract_violation_data(text, pdf_file)

        # Добавляем имя файла
        extracted_data['Номер файла'] = pdf_file

        all_data.append(extracted_data)
    return all_data

# Путь к папке с PDF файлами
today = date.today()
# Формируем имя папки на основе текущей даты (формат ДД.ММ.ГГГГ)
pdf_folder_name = today.strftime("%d.%m.%Y")
pdf_folder = os.path.join("/content", f"{pdf_folder_name}_downloads")

# Обработка PDF файлов
all_data = process_pdf_files(pdf_folder)

# Создание DataFrame
df = pd.DataFrame(all_data)

# Перестановка столбцов
column_order = [
    'Номер файла',
    'Номер постановления',
    'Дата нарушения',
    'Время нарушения',
    'Адрес нарушения',
    'Гос номер ТС',
    'Сумма штрафа',
    'Номер СТС',
    'Фотография ТС',
    'Фото гос номера ТС',
    'ИГР знак'
]
df = df[column_order]

# Вывод таблицы
print(df.to_string())

# Путь для сохранения файла
output_folder = "/content/output"  # Папка для сохранения результата
if not os.path.exists(output_folder):
    os.makedirs(output_folder)

# Сохранение таблицы в CSV
csv_path = os.path.join(output_folder, "violations_data.csv")
df.to_csv(csv_path, index=False, encoding="utf-8-sig")

print(f"Таблица успешно сохранена в файлы:\n - {csv_path}")

# --- 5.

# Функция для извлечения данных из PDF
def extract_pdf_data(pdf_path):
    try:
        doc = fitz.open(pdf_path)
        text = ""

        # Извлекаем текст с каждой страницы
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            text += page.get_text("text")

        return text
    except Exception as e:
        print(f"Error extracting data from {pdf_path}: {e}")
        return ""


# Функция для извлечения данных о нарушении
def extract_violation_data(text, pdf_file):
    # Приведение текста к верхнему регистру для унификации
    text = text.upper()

    # Инициализация переменных
    violation_number, fine_amount = None, None

    # Номер постановления
    match_number = re.search(r'ПОСТАНОВЛЕНИЕ\s+(\d+)', text)
    if match_number:
        violation_number = match_number.group(1)

    # Сумма штрафа
    fine_patterns = [
        r'НАЗНАЧИТЬ\s+.*?\s+ШТРАФА\s+В\s+РАЗМЕРЕ\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)',
        r'ШТРАФ\s+В\s+(РАЗМЕРЕ|СУММЕ)\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)',
        r'РАЗМЕР\s+ШТРАФА\s+СОСТАВЛЯЕТ\s+(\d{1,3}(?:[.\s]\d{3})*|\d+)\s*(РУБ|РУБЛЕЙ)'
    ]

    for pattern in fine_patterns:
        match_fine = re.search(pattern, text)
        if match_fine:
            fine_amount = match_fine.group(1)
            fine_amount = fine_amount.replace(" ", "").replace(".", "").replace("\xa0", "")  # Удаление пробелов
            fine_amount = int(fine_amount)
            break
    else:
        fine_amount = 0  # Если сумма не найдена

    return {
        'Номер постановления': violation_number or "Не найдено",
        'Сумма штрафа': fine_amount,
        'Сумма штрафа > или < 5000 (True/False)': fine_amount > 5000
    }


# Функция для обработки всех PDF и обновления файла CSV
def process_all_pdfs(pdf_folder, csv_output):
    pdf_files = [f for f in os.listdir(pdf_folder) if f.endswith('.pdf')]

    # Загружаем существующий файл CSV в DataFrame, если файл существует, иначе создаем новый
    if os.path.isfile(csv_output):
        df = pd.read_csv(csv_output)
    else:
        df = pd.DataFrame()

    for pdf_file in pdf_files:
        pdf_path = os.path.join(pdf_folder, pdf_file)
        text = extract_pdf_data(pdf_path)

        if not text:  # Skip if no data was extracted
            continue

        extracted_data = extract_violation_data(text, pdf_file)

        # Если запись найдена, обновляем её; иначе добавляем новую строку
        idx = df[df['Номер постановления'] == extracted_data['Номер постановления']].index

        if not idx.empty:
            df.loc[idx, 'Сумма штрафа'] = extracted_data['Сумма штрафа']
            df.loc[idx, 'Сумма штрафа > или < 5000 (True/False)'] = extracted_data[
                'Сумма штрафа > или < 5000 (True/False)']
        else:
            new_row = {key: None for key in df.columns}  # Создаём шаблон строки
            new_row.update(extracted_data)  # Заполняем новой информацией
            df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)

        # Вывод для отладки
        print(f"Файл: {pdf_file}")
        print(f"Номер постановления: {extracted_data['Номер постановления']}")
        print(f"Сумма штрафа: {extracted_data['Сумма штрафа']}")
        print(f"Флаг: {extracted_data['Сумма штрафа > или < 5000 (True/False)']}")
        print("-" * 50)

    # Убедимся, что новый столбец вставлен между 'Сумма штрафа' и 'Номер СТС'
    cols = df.columns.tolist()
    sum_index = cols.index('Сумма штрафа')
    if 'Сумма штрафа > или < 5000 (True/False)' in cols:
        cols.remove('Сумма штрафа > или < 5000 (True/False)')
    cols.insert(sum_index + 1, 'Сумма штрафа > или < 5000 (True/False)')
    df = df[cols]

    # Запись в CSV
    df.to_csv(csv_output, index=False, encoding='utf-8-sig')
    print(f"Данные записаны в файл:\nCSV: {csv_output}")


# Главный блок
if __name__ == "__main__":
    today = date.today()  # Получаем текущую дату
    pdf_folder_name = today.strftime("%d.%m.%Y")  # Формируем имя папки на основе текущей даты (формат ДД.ММ.ГГГГ)
    pdf_folder = os.path.join("/content", f"{pdf_folder_name}_downloads")
    csv_output = '/content/output/violations_data.csv'  # Путь для сохранения CSV

    # Обработка всех PDF
    process_all_pdfs(pdf_folder, csv_output)

# --- 6. Компьютерное зрение для распознавания номеров ---

# Настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Конвертация PDF в изображение
def pdf_to_image(pdf_path, output_folder='output_images'):
    """Конвертирует PDF в изображение (первая страница)."""
    if not os.path.exists(output_folder):
        os.makedirs(output_folder)
    try:
        images = convert_from_path(pdf_path, poppler_path='/usr/bin')
        image_path = os.path.join(output_folder, "page1.jpeg")
        images[0].save(image_path, 'JPEG')
        return image_path
    except Exception as e:
        logging.error(f"Ошибка при конвертации PDF в изображение: {e}")
        return None

# Загрузка изображения и распознавание текста c Tesseract
def ocr_image_tesseract(image_path, contrast=2.0, sharpness=2.0, resize_factor=1.5):
    """Распознает текст на изображении с помощью Tesseract."""
    try:
        image = Image.open(image_path)
        if resize_factor != 1:
            new_size = (int(image.width * resize_factor), int(image.height * resize_factor))
            image = image.resize(new_size, Image.Resampling.LANCZOS)
        image = image.convert("L")
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(contrast)
        sharpener = ImageEnhance.Sharpness(image)
        image = sharpener.enhance(sharpness)
        text = pytesseract.image_to_string(image, lang='rus')
        return text
    except Exception as e:
        logging.error(f"Ошибка при распознавании текста Tesseract: {e}")
        return None

# Нахождение номера ТС в тексте
def extract_plate_from_text(text):
    """Извлекает номер ТС из текста по ключевому слову."""
    if not text:
        return None
    keyword = "государственный регистрационный знак"
    match = re.search(rf'{keyword}\s*([АВЕКМНОРСТУХABEKMHOPCTYX]\s*\d{{3}}\s*[АВЕКМНОРСТУХABEKMHOPCTYX]{{2}}\s*\d{{2,3}})', text, re.IGNORECASE)
    if match:
        return _normalize_plate(match.group(1))
    else:
        return None

# Распознавание номера ТС на фото
def ocr_plate_from_image(image_path):
    """Распознает номер ТС на изображении с помощью EasyOCR."""
    try:
        reader = easyocr.Reader(['ru'])
        image = cv2.imread(image_path)
        if image is None:
            logging.error(f"Не удалось прочитать изображение по пути: {image_path}")
            return None
        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        gray = cv2.medianBlur(gray, 5)
        thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 5)

        results = reader.readtext(thresh)
        plates = [result[1] for result in results if re.match(r'[АВЕКМНОРСТУХABEKMHOPCTYX]\d{3}[АВЕКМНОРСТУХABEKMHOPCTYX]{2}\d{2,3}', result[1])]
        if plates:
            return _normalize_plate(plates[0])
        else:
          return None
    except Exception as e:
        logging.error(f"Ошибка при распознавании номера с изображения: {e}")
        return None

# Унифицированная функция для нормализации номеров
def _normalize_plate(plate):
    """Нормализует номер ТС, удаляя пробелы, запятые, точки, двоеточия и невидимые символы."""
    if plate is None:
      return None
    if plate:
        plate = plate.upper()
        plate = re.sub(r'[\s,.;:\n\t]', '', plate)
        return plate
    return plate

def compare_plates(text_plate, image_plate):
    """Сравнивает два номера ТС."""
    if text_plate and image_plate:
      return text_plate == image_plate
    else:
      return False

# Функция для обработки одного PDF
def process_single_pdf(pdf_path):
    """Обрабатывает один PDF файл."""
    logging.info(f"Обработка PDF: {pdf_path}")
    image_path = pdf_to_image(pdf_path)
    if not image_path:
      logging.error(f"Не удалось получить изображение из {pdf_path}")
      return None, None, False
    text = ocr_image_tesseract(image_path)
    text_plate = extract_plate_from_text(text)
    image_plate = ocr_plate_from_image(image_path)
    result = compare_plates(text_plate, image_plate)
    logging.info(f"Результаты: Text Plate={text_plate}, Image Plate={image_plate}, Match={result}")
    return text_plate, image_plate, result

# Функция для обработки всех PDF в папке
def process_pdf_folder(folder_path, output_csv="/content/output/violations_data.csv"):
    """Обрабатывает все PDF файлы в указанной папке и записывает результаты в CSV."""
    if not os.path.exists(folder_path):
        logging.error(f"Папка не найдена: {folder_path}")
        return

    # Читаем существующий CSV файл
    try:
      df = pd.read_csv(output_csv)
    except FileNotFoundError:
        logging.error(f"Файл CSV не найден: {output_csv}")
        return

    new_column_data = []
    for filename in os.listdir(folder_path):
        if filename.lower().endswith(".pdf"):
            pdf_path = os.path.join(folder_path, filename)
            try:
              text_plate, image_plate, result = process_single_pdf(pdf_path)
              new_column_data.append(result)
            except Exception as e:
                logging.error(f"Ошибка при обработке PDF {pdf_path}: {e}")
                new_column_data.append(False) # Если ошибка, то ставим False

    # Вставляем новый столбец после столбца "Фото гос номера ТС"
    try:
      insert_loc = df.columns.get_loc("Фото гос номера ТС") + 1
      df.insert(insert_loc, "Фото гос номера соответствует (True/False)", new_column_data)
    except KeyError:
      logging.error(f"Столбец 'Фото гос номера ТС' не найден в CSV.")
      return

    # Сохраняем обновленный DataFrame обратно в CSV
    df.to_csv(output_csv, index=False, encoding='utf-8')
    return

# Получаем текущую дату
today = date.today()
# Формируем имя папки на основе текущей даты (формат ДД.ММ.ГГГГ)
pdf_folder_name = today.strftime("%d.%m.%Y")
# Формируем полный путь к папке с PDF файлами
pdf_folder = os.path.join("/content", f"{pdf_folder_name}_downloads")
# Задаем путь к выходному CSV файлу
output_csv = "/content/output/violations_data.csv"  # Полный путь

# Проверяем, существует ли директория для сохранения CSV файла, если нет, создаем ее
if not os.path.exists(os.path.dirname(output_csv)):
  os.makedirs(os.path.dirname(output_csv)) # Создаем директорию output если ее нет

# Обрабатываем PDF файлы из папки и получаем DataFrame с результатами
process_pdf_folder(pdf_folder, output_csv=output_csv)
print("Данные успешно сохранены в CSV.")

# --- 7. Email-уведомления по штрафам и несоответствиям

# Пути к файлам и папкам
CSV_FILE = '/content/output/violations_data.csv'
IMAGE_DIR = '/content/images'

# Параметры почты
SENDER_EMAIL = 'nikita5867@gmail.com'
SENDER_PASSWORD = 'hnnt eoua jifr ktnv'  # Замените на ваш пароль
RECEIVER_EMAIL_IPFARM = 'o2rus.tech@gmail.com'
RECEIVER_EMAIL_YRA = 'cargo-web@o2rus.ru'

def send_email(to_email, subject, body, attachments=None):
    """Отправляет письмо с заданными параметрами."""
    with yagmail.SMTP(SENDER_EMAIL, SENDER_PASSWORD) as yag:
        yag.send(to=to_email, subject=subject, contents=body, attachments=attachments)

def process_data():
    """Читает данные из CSV и Excel, обрабатывает их и отправляет письма."""
    try:
      df_csv = pd.read_csv(CSV_FILE)
    except FileNotFoundError:
        print(f"Ошибка: Файл {CSV_FILE} не найден.")
        return

    try:
        df_excel = pd.read_excel(EXCEL_FILE)
    except FileNotFoundError:
       print(f"Ошибка: Файл {EXCEL_FILE} не найден.")
       return

    # Объединяем данные
    df = pd.concat([df_csv, df_excel], ignore_index=True)

    for index, row in df.iterrows():

        # Обработка для o2rus.tech@gmail.com
        if row["# 'Фото гос номера соответствуют (True/False)'"] == False:
            # Извлекаем номер PDF из имени файла и составляем имя изображения
            pdf_file_number = row['#fileName'].split('.')[0]
            image_file = os.path.join(IMAGE_DIR, f"{pdf_file_number}.pdf_page_0_img_0.jpeg")

            if os.path.exists(image_file):
                 send_email(
                    to_email=RECEIVER_EMAIL_IPFARM,
                    subject="Нарушение: неверный гос номер",
                    body=f"Обнаружено нарушение в строке {index + 1}. Прилагается изображение.",
                    attachments=[image_file]
                )
                 print(f"Отправлено письмо на o2rus.tech@gmail.com для строки {index + 1}")
            else:
                print(f"Ошибка: изображение {image_file} для строки {index + 1} не найдено.")


        # Обработка для cargo-web@o2rus.ru
        if row["# 'Сумма штрафа > или < 5000 (True/False)'"] == True:
             send_email(
                to_email=RECEIVER_EMAIL_YRA,
                subject="Нарушение: штраф более 5000",
                body=f"Обнаружено нарушение в строке {index + 1}. Штраф превышает 5000.",
                )
             print(f"Отправлено письмо на cargo-web@o2rus.ru для строки {index + 1}")

if __name__ == "__main__":
    process_data()

# --- 8. Создание итоговой таблице с подсчетом нарушений и отправкой на почту
    #def create_summary_table(csv_path):
    """
    Создает итоговую таблицу с подсчетом нарушений по адресам.

    Args:
      csv_path: Путь к CSV-файлу с данными о нарушениях.

    Returns:
      pandas.DataFrame: Итоговая таблица.  Возвращает None при ошибках.
    """
    try:
        # Загрузка данных из CSV
        df_csv = pd.read_csv(csv_path)
    except FileNotFoundError as e:
        print(f"Ошибка при чтении CSV: {e}")
        return None
    except pd.errors.EmptyDataError:
        print("CSV файл пуст")
        return None
    except Exception as e:
        print(f"Ошибка при чтении CSV: {e}")
        return None

    # Обработка пустых значений в столбце 'Адрес нарушения'
    df_csv = df_csv.dropna(subset=['Адрес нарушения'])

    # Подсчет количества нарушений по адресам
    summary_df = df_csv['Адрес нарушения'].value_counts().reset_index()
    summary_df.columns = ['Адрес местоположения', 'Количество']
    summary_df.sort_values('Количество', ascending=False, inplace=True) # Сортировка

    # Добавляем нумерацию
    summary_df.insert(0, '№', range(1, len(summary_df) + 1))
    return summary_df

def send_email(summary_table, recipient_email, sender_email, sender_password):
    """
    Отправляет итоговую таблицу на почту в формате Excel.

    Args:
        summary_table (pandas.DataFrame): Итоговая таблица.
        recipient_email (str): Адрес электронной почты получателя.
        sender_email (str): Адрес электронной почты отправителя (Gmail).
        sender_password (str): Пароль электронной почты отправителя (Gmail).
    """

    # Создание временного файла для таблицы
    temp_file = "summary_table.xlsx"
    summary_table.to_excel(temp_file, index=False)

    # Формирование письма
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email
    message['Subject'] = "Итоговая таблица нарушений"

    # Текст письма
    body = "Прилагается итоговая таблица с количеством нарушений по адресам."
    message.attach(MIMEText(body, 'plain'))

    # Добавление файла с таблицей в качестве вложения
    with open(temp_file, "rb") as attachment:
        part = MIMEApplication(attachment.read(), Name=os.path.basename(temp_file))
    part['Content-Disposition'] = f'attachment; filename="{os.path.basename(temp_file)}"'
    message.attach(part)

    try:
       # Подключение к SMTP-серверу и отправка
       server = smtplib.SMTP("smtp.gmail.com", 587)
       server.starttls()
       server.login(sender_email, sender_password)
       server.sendmail(sender_email, recipient_email, message.as_string())
       server.quit()
       print("Письмо с таблицей успешно отправлено.")
    except Exception as e:
       print(f"Ошибка при отправке письма: {e}")
    finally:
        # Удаление временного файла
       os.remove(temp_file)

if __name__ == "__main__":
    csv_file_path = "/content/output/violations_data.csv"

    summary_table = create_summary_table(csv_file_path)

    if summary_table is not None:
        print("Итоговая таблица:")
        print(summary_table)

        recipient = "o2rus.tech@gmail.com"
        sender = "nikita5867@gmail.com"  # Ваш адрес Gmail
        password = "hnnt eoua jifr ktnv"  # Ваш пароль от Gmail  (Свой пароль удалить)
        send_email(summary_table, recipient, sender, password)